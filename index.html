<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.7.0/d3.js"
      integrity="sha512-+4O1tTAf2Ku73pJ0uXuoTFbXM8agSnDhmqlMylH37E1JvyLu+ZoX2Cr/E16Xljt9R9WD1tzgRXGLQPb2YT1m1A=="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"
      integrity="sha512-qTXRIMyZIFb8iQcfjXWCO8+M5Tbc38Qi5WzdPOYZHIlZpzBHG3L3by84BBBOiRGiEb7KKtAOAs5qYdUiZiQNNQ=="
      crossorigin="anonymous"
    ></script>
    <title>Bubbles: Stonks</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  </head>
  <body>
    <div class="app">
      <svg></svg>
      <div class="slidecontainer">
        <input type="range" min="0" max="100" value="0" class="slider" id="myRange" />
      </div>
      <div class="controls">
        <button id="play">Play</button>
        <button id="stop">Stop</button>
        <button id="speedDown">-</button>
        <button id="speedUp">+</button>
        <span id="tickspersecond">4 ticks per second</span>
        <div class="form-select" style="margin-left: 30px; margin-top: auto; margin-bottom: auto;">
          <select id="stockDeltaPTimespan">
              <option value="3">3 minutes</option>
              <option value="5" selected>5 minutes</option>
              <option value="10">10 minutes</option>
              <option value="25">25 minutes</option>
              <option value="40">40 minutes</option>
              <option value="60">1 hour</option>
              <option value="120">2 hours</option>
              <option value="180">3 hours</option>
              <option value="240">4 hours</option>
          </select>
        </div>
        <button type="button" class="btn btn-success" style="width: auto; margin-left: 30px; margin-top: auto; margin-bottom: auto; padding: 0 12px;" onclick="fetchData('null')">Get Stonks</button>
      </div>
      <div class="controls">
        <div class="scale-input">
          <label>Min Y%:</label>
          <input type="text" id="yMin" name="yMin" />
        </div>
        <div class="scale-input">
          <label>Max Y%:</label>
          <input type="text" id="yMax" name="yMax" />
        </div>
        <button style="width: 8em" id="setY">Set Y-Axis</button>
        <button style="width: 8em" id="autoSetY">Auto Set Y</button>
      </div>
      <div class="controls">
        <div class="scale-input" style="width: 6em">
          <label>Min X:</label>
          <select name="minX" id="minX" style="width: 8em">
            <option value="1" selected>1</option>
            <option value="10">10</option>
            <option value="100">100</option>
            <option value="1000">1,000</option>
            <option value="10000">10,000</option>
            <option value="100000">100,000</option>
            <option value="1000000">1,000,000</option>
            <option value="10000000">10,000,000</option>
            <option value="100000000">100,000,000</option>
            <option value="1000000000">1,000,000,000</option>
          </select>
        </div>
        <div class="scale-input" style="width: 6em">
          <label>Max X:</label>
          <select name="maxX" id="maxX" style="width: 8em">
            <option value="1">1</option>
            <option value="10">10</option>
            <option value="100">100</option>
            <option value="1000">1,000</option>
            <option value="10000">10,000</option>
            <option value="100000">100,000</option>
            <option value="1000000">1,000,000</option>
            <option value="10000000">10,000,000</option>
            <option value="100000000" selected>100,000,000</option>
            <option value="1000000000">1,000,000,000</option>
          </select>
        </div>
        <button style="width: 8em" id="autoSetX">Auto Set X</button>
      </div>
    </div>
  </body>
</html>
<script>
  //   const width = 1920;
  //   const height = 1080;
  let width = document.querySelector(".app").clientWidth;
  let height = document.querySelector(".app").clientHeight;
  const m = [140, 20, 120, 140];
  const radius = 5;
  let timeIndex = 0; // index of array in json file for the displayed tick
  let activeStock; // the stock that was clicked on the chart
  let xForceStrength = 0.04;
  let yForceStrength = 0.99;
  let alpha = 0.3;
  let alphaDecay = 0.1;
  let decayTimeout; // reference to timeout ID for applying alpha decay
  let intervalTimer; // reference for setInterval ID so we can stop animation
  let frequency = 250; // animation update frequency
  let xMin = 1;
  let xMax = 1e8; // Math.exp(xMax) is the x-axis bound
  let yMin = -10; // in percent
  let yMax = 10;
  let tickinterval = 0.5; // in percent
  const x = d3.scaleLog();
  const y = d3.scaleLinear();
  const timeoutList = [];
  let animate = false;
  let tickers = [];

  const svg = d3.select("svg").attr("height", height).attr("width", width);

  // color gradients for traceline vectors
  const defs = svg.append("defs");
  let gradient = defs.append("linearGradient").attr("id", "green-right");
  gradient.append("stop").attr("stop-color", "rgb(6, 195, 125, 1)").attr("offset", 0).attr("stop-opacity", 0);
  gradient.append("stop").attr("stop-color", "rgb(6, 195, 125, 1)").attr("offset", 1).attr("stop-opacity", 1);
  gradient = defs.append("linearGradient").attr("id", "green-left");
  gradient.append("stop").attr("stop-color", "rgb(6, 195, 125, 1)").attr("offset", 0).attr("stop-opacity", 1);
  gradient.append("stop").attr("stop-color", "rgb(6, 195, 125, 1)").attr("offset", 1).attr("stop-opacity", 0);
  gradient = defs.append("linearGradient").attr("id", "red-right");
  gradient.append("stop").attr("stop-color", "rgb(253, 50, 55, 1)").attr("offset", 0).attr("stop-opacity", 0);
  gradient.append("stop").attr("stop-color", "rgb(253, 50, 55, 1)").attr("offset", 1).attr("stop-opacity", 1);
  gradient = defs.append("linearGradient").attr("id", "red-left");
  gradient.append("stop").attr("stop-color", "rgb(253, 50, 55, 1)").attr("offset", 0).attr("stop-opacity", 1);
  gradient.append("stop").attr("stop-color", "rgb(253, 50, 55, 1)").attr("offset", 1).attr("stop-opacity", 0);

  const slider = document.getElementById("myRange");

  const titletext = svg
    .append("g")
    .append("text")
    .attr("x", m[3])
    .attr("y", 100)
    .attr("font-family", "sans-serif")
    .attr("font-size", 32)
    .attr("fill", "grey");

  const tickertext = svg
    .append("g")
    .append("text")
    .attr("x", width - m[1] - m[3])
    .attr("y", 100)
    .attr("font-family", "sans-serif")
    .attr("font-size", 32)
    .attr("fill", "grey")
    .attr("text-anchor", "end");

  // open a json file, or open an API, websocket, or SSE event for streaming data
  var fetchDataHasRan = false
  var hasFetchDataRanAndCompleted = 0;
  var stockData = "null";
  async function fetchData(stockData) {
    return new Promise(function(resolve, reject) {
      //let data = await fetch("./data/bubbles.json");
      if (hasFetchDataRanAndCompleted == 1) {
        location.reload();
      }
      hasFetchDataRanAndCompleted = 1;
      var selectElement = document.getElementById("stockDeltaPTimespan");
      var selectedOption = selectElement.options[selectElement.selectedIndex].value;
      console.log(selectedOption);
      let xhr = new XMLHttpRequest();
      if (xhr.readyState !== 0) {
        xhr.abort();
      }
      xhr.open("POST", "http://127.0.0.1:5000/bubbles_script");
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.send(JSON.stringify({ "stockDeltaPTimespan": selectedOption, stockData }));
      xhr.onload = function() {
        let result = this.responseText;
        result = JSON.parse(result);
        hasFetchDataRanAndCompleted = 2;
        if (fetchDataHasRan == true) {
          resolve(result);
        }
        else {
          fetchDataHasRan = true;
          resolve(init(result));
        }
      };
    });
    //return await response;
  }

  async function init(data) {
    //let data = await fetchData();
    console.log("data", data);

    // y-axis scale for change in price
    y.domain([yMin, yMax]).range([height - m[2], m[0]]);
    y.clamp(true);
    // x-axis scale for volume
    x.domain([xMin, xMax]).range([m[3], width - m[1] - m[3]]);
    x.clamp(true);

    slider.min = 0;
    slider.max = data.length - 1;

    drawgrid(svg, x, y);

    tickers = [];
    Object.values(data[0])[0].forEach((d, i) => {
      console.log(data[0]);
      console.log(d)
      console.log(i)
      tickers.push({ stock: d.stock, index: i });
    });

    svg
      .selectAll(".stock")
      .data(tickers)
      .enter()
      .append("circle")
      .attr("class", "stock")
      .attr("fill", "lightsteelblue")
      .attr("stroke", "black")
      .attr("stroke-width", 1)
      .attr("r", radius)
      .on("click", function () {
        d3.selectAll(".stock").attr("stroke", "black").attr("stroke-width", 1);
        const circle = d3.select(this);
        activeStock = d3.select(this);
        circle.attr("stroke", "red").attr("stroke-width", 2);
        tickertext.text(
          `${circle.data()[0].stock} ${Object.values(data[timeIndex])[0][circle.data()[0].index].delta_p.toFixed(2)}%`
        );
        console.log(circle.data()[0]);
        console.log(Object.values(data[timeIndex])[0][circle.data()[0].index].delta_p);
      });

    function tick() {
      // update circle positions
      d3.selectAll(".stock")
        .attr("cx", (d) => d.x)
        .attr("cy", (d) => d.y);

      // update tracelines to follow circles
      svg
        .selectAll(".traceline")
        .attr("x2", (d) => d.x)
        .attr("y2", (d) => d.y)
        .attr("stroke", (d) => {
          if (d.vy < 0) {
            if (d.vx >= 0) return "url(#green-right)";
            else return "url(#green-left)";
          } else {
            if (d.vx >= 0) return "url(#red-right)";
            else return "url(#red-left)";
          }
        });
    }

    const simulation = d3
      .forceSimulation(tickers)
      .force(
        "y",
        d3
          .forceY(function (d) {
            return y(Object.values(data[timeIndex])[0][d.index]["delta_p"]);
          })
          .strength(yForceStrength)
      )
      .force(
        "x",
        d3
          .forceX((d) => {
            return x(Object.values(data[timeIndex])[0][d.index]["delta_v"] || 1);
          })
          .strength(xForceStrength)
      )
      .force("collide", d3.forceCollide(radius))
      .alphaDecay(0)
      .alpha(alpha)
      .on("tick", tick);

    decayTimeout = setTimeout(function () {
      console.log("init alpha decay");
      simulation.alphaDecay(0.1);
    }, 3000);

    window.addEventListener("resize", () => {
      console.log("resize");
      width = document.querySelector(".app").clientWidth;
      height = document.querySelector(".app").clientHeight;
      svg.attr("width", width);
      svg.attr("height", height);
      y.domain([yMin, yMax]).range([height - m[2], m[0]]);
      x.domain([xMin, xMax]).range([m[3], width - m[1] - m[3]]);
      tickertext.attr("x", width - m[1] - m[3]);
      drawgrid(svg, x, y);
      updateSim(simulation, data);
    });

    // Update forces when we move the slider
    // If streaming data, use a listener for SSE or Websocket events
    slider.oninput = function () {
      timeIndex = parseInt(this.value);
      updateSim(simulation, data);
      drawTracelines();
      titletext.text(moment(parseInt(Object.keys(data[timeIndex])[0])).format("YYYY-MM-DD HH:mm:ss:SSS"));
      if (activeStock) {
        tickertext.text(
          `${activeStock.data()[0].stock} ${Object.values(data[timeIndex])[0][
            activeStock.data()[0].index
          ].delta_p.toFixed(2)}%`
        );
      }
    };

    //start animation
    d3.select("#play").on("click", function () {
      console.log("animate");
      console.log(Object.values(data[timeIndex])[0]);
      animate = true;
      document.querySelector("#play").disabled = true;

      isIntervalRunning = true;
      intervalTimer = setInterval(async() => {
        if (!isIntervalRunning) {
          return;
        }
        isIntervalRunning = false
        slider.value = timeIndex;
        
        //document.getElementById("autoSetY").click();
        console.log(frequency);
        console.log("yo");
        data = await fetchData(data);
        console.log("yo2");

        if (timeIndex < data.length) {
          updateSim(simulation, data);
          titletext.text(moment(parseInt(Object.keys(data[timeIndex])[0])).format("YYYY-MM-DD HH:mm:ss:SSS"));
          if (activeStock) {
            tickertext.text(
              `${activeStock.data()[0].stock} ${Object.values(data[timeIndex])[0][
                activeStock.data()[0].index
              ].delta_p.toFixed(2)}%`
            );
          }
        }

        drawTracelines();

        if (timeIndex < data.length - 1) {
          timeIndex += 1;
        } else {
          // clearInterval(intervalTimer);
          // document.querySelector("#play").disabled = false;
          // animate = false;
        }
        isIntervalRunning = true;
      }, frequency);
    });

    d3.select("#stop").on("click", function () {
      console.log("stop");
      animate = false;
      document.querySelector("#play").disabled = false;
      clearInterval(intervalTimer);
    });

    d3.select("#speedUp").on("click", function () {
      console.log("speed up");
      let tps = 1000 / frequency;
      tps = tps + 1 > 20 ? 20 : tps + 1;
      frequency = 1000 / tps;
      d3.select("#tickspersecond").text(`${tps.toFixed(0)} ticks per second`);
      console.log("frequency", frequency);
      clearInterval(intervalTimer);
      if (animate) d3.select("#play").on("click")();
    });

    d3.select("#speedDown").on("click", function () {
      console.log("speed down");
      let tps = 1000 / frequency;
      tps = tps - 1 < 1 ? 1 : tps - 1;
      frequency = 1000 / tps;
      d3.select("#tickspersecond").text(`${tps.toFixed(0)} ticks per second`);
      console.log("frequency", frequency);
      clearInterval(intervalTimer);
      if (animate) d3.select("#play").on("click")();
    });

    d3.select("#autoSetY").on("click", function () {
      autoSetY(simulation, data);
    });

    d3.select("#autoSetX").on("click", function () {
      autoSetX(simulation, data);
    });

    d3.select("#setY").on("click", function () {
      setY(simulation, data);
    });

    d3.select("#minX").on("change", function (e) {
      xMin = document.querySelector("#minX").value;
      x.domain([xMin, xMax]);
      drawgrid(svg, x, y);
      updateSim(simulation, data);
    });

    d3.select("#maxX").on("change", function (e) {
      xMax = document.querySelector("#maxX").value;
      x.domain([xMin, xMax]);
      drawgrid(svg, x, y);
      updateSim(simulation, data);
    });
  }

  function drawTracelines() {
    svg.selectAll(".traceline").remove();
    svg
      .selectAll(".traceline")
      .data(tickers)
      .enter()
      .append("line")
      .attr("class", "traceline")
      .attr("stroke", (d) => `url(#gradient)`)
      .attr("x1", (d) => d.x)
      .attr("x2", (d) => d.x)
      .attr("y1", (d) => d.y)
      .attr("y2", (d) => d.y)
      .attr("stroke-width", 2)
      .attr("opacity", 1)
      .lower()
      .transition()
      .duration(2000)
      .attr("opacity", 0)
      .remove();
  }

  function autoSetY(simulation, data) {
    let thisTick = Object.values(data[timeIndex])[0];
    y.domain([d3.min(thisTick, (d) => d.delta_p), d3.max(thisTick, (d) => d.delta_p)]); // calibrate axis
    yMin = Math.round(y.domain()[0]); // in percent, so 1 percent is yMin = 1
    yMax = Math.round(y.domain()[1]);
    drawgrid(svg, x, y);
    updateSim(simulation, data);
  }

  function autoSetX(simulation, data) {
    let thisTick = Object.values(data[timeIndex])[0];
    x.domain([d3.min(thisTick, (d) => d.delta_v) || 1, d3.max(thisTick, (d) => d.delta_v)]); // calibrate axis
    xMin = Math.round(x.domain()[0]);
    xMax = Math.round(x.domain()[1]);
    drawgrid(svg, x, y);
    updateSim(simulation, data);
  }

  function setY(simulation, data) {
    yMin = parseFloat(document.querySelector("#yMin").value) || yMin;
    yMax = parseFloat(document.querySelector("#yMax").value) || yMax;
    y.domain([yMin, yMax]);
    drawgrid(svg, x, y);
    updateSim(simulation, data);
  }

  function updateSim(simulation, data) {
    simulation
      .force(
        "y",
        d3.forceY(function (d) {
          return y(Object.values(data[timeIndex])[0][d.index]["delta_p"]);
        })
      )
      .force(
        "x",
        d3.forceX((d) => {
          return x(Object.values(data[timeIndex])[0][d.index]["delta_v"] || 1);
          //   return x(Math.log(Object.values(data[timeIndex])[0][d.index]["volume"] || 1));
        })
      );

    simulation.alphaDecay(0).alpha(alpha).restart();
    clearTimeout(decayTimeout);
    decayTimeout = setTimeout(function () {
      console.log("init alpha decay");
      simulation.alphaDecay(0.1);
    }, 3000);
  }

  function drawgrid(svg, x, y) {
    console.log("drawgrid");
    y.nice();
    // zero line
    svg.select(".gridlines").remove();
    let g = svg.append("g").attr("class", "gridlines").lower();

    // zero percent line
    g.append("line")
      .attr("x1", 100)
      .attr("x2", width - 100)
      .attr("y1", y(0))
      .attr("y2", y(0))
      .attr("stroke", "rgba(0,0,0,0.2")
      .attr("stroke-dasharray", "12 4")
      .attr("stroke-width", "2");

    y.ticks().forEach((tick, i) => {
      if (tick !== 0) {
        g.append("line")
          .attr("x1", 100)
          .attr("x2", width - 100)
          .attr("y1", y(tick))
          .attr("y2", y(tick))
          .attr("stroke", "rgba(0,0,0,0.15")
          .attr("stroke-width", "1");
      }
      g.append("text") // left labels
        .attr("x", 80)
        .attr("y", y(tick))
        .attr("fill", "black")
        .attr("alignment-baseline", "middle")
        .attr("text-anchor", "end")
        .text(tick + "%");
    });

    // x-grid (vertical lines)
    // number of ticks should align with the powers of 10 in the domain
    x.nice();
    x.ticks(xMax.toString().length - xMin.toString().length).forEach((tick) => {
      g.append("line")
        .attr("x1", x(tick))
        .attr("x2", x(tick))
        .attr("y1", y.range()[0])
        .attr("y2", y.range()[1])
        .attr("stroke", "rgba(0,0,0,0.15")
        .attr("stroke-width", "1");
      g.append("text")
        .attr("x", x(tick))
        .attr("y", y.range()[0] + 30)
        .attr("fill", "black")
        .attr("text-anchor", "middle")
        .text(tick.toLocaleString("en-US"));
    });

    g.append("text")
      .attr("x", width / 2)
      .attr("y", y.range()[0] + 60)
      .attr("fill", "black")
      .attr("text-anchor", "middle")
      .text("Volume");
  }

  //fetchData();
</script>
